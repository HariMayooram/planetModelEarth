{
  "version": 3,
  "sources": ["../../@langchain/community/dist/utils/event_source_parse.js", "../../@langchain/community/dist/llms/togetherai.js"],
  "sourcesContent": ["import { IterableReadableStream } from \"@langchain/core/utils/stream\";\nexport const EventStreamContentType = \"text/event-stream\";\nfunction isNodeJSReadable(x) {\n    return x != null && typeof x === \"object\" && \"on\" in x;\n}\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(stream, onChunk) {\n    // stream is a Node.js Readable / PassThrough stream\n    // this can happen if node-fetch is polyfilled\n    if (isNodeJSReadable(stream)) {\n        return new Promise((resolve) => {\n            stream.on(\"readable\", () => {\n                let chunk;\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    chunk = stream.read();\n                    if (chunk == null) {\n                        onChunk(new Uint8Array(), true);\n                        break;\n                    }\n                    onChunk(chunk);\n                }\n                resolve();\n            });\n        });\n    }\n    const reader = stream.getReader();\n    // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n    //          This change is essential to ensure that we capture every last piece of information from streams,\n    //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n    //          mechanism, we risk ignoring a possibly significant last message.\n    //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const result = await reader.read();\n        if (result.done) {\n            onChunk(new Uint8Array(), true);\n            break;\n        }\n        onChunk(result.value);\n    }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr, flush) {\n        if (flush) {\n            onLine(arr, 0, true);\n            return;\n        }\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength, flush) {\n        if (flush) {\n            if (!isEmpty(message)) {\n                onMessage?.(message);\n                message = newMessage();\n            }\n            return;\n        }\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\nexport function convertEventStreamToIterableReadableDataStream(stream) {\n    const dataStream = new ReadableStream({\n        async start(controller) {\n            const enqueueLine = getMessages((msg) => {\n                if (msg.data)\n                    controller.enqueue(msg.data);\n            });\n            const onLine = (line, fieldLength, flush) => {\n                enqueueLine(line, fieldLength, flush);\n                if (flush)\n                    controller.close();\n            };\n            await getBytes(stream, getLines(onLine));\n        },\n    });\n    return IterableReadableStream.fromReadableStream(dataStream);\n}\nfunction isEmpty(message) {\n    return (message.data === \"\" &&\n        message.event === \"\" &&\n        message.id === \"\" &&\n        message.retry === undefined);\n}\n", "import { LLM, } from \"@langchain/core/language_models/llms\";\nimport { GenerationChunk } from \"@langchain/core/outputs\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport { convertEventStreamToIterableReadableDataStream } from \"../utils/event_source_parse.js\";\nexport class TogetherAI extends LLM {\n    static lc_name() {\n        return \"TogetherAI\";\n    }\n    constructor(inputs) {\n        super(inputs);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"repetitionPenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1\n        });\n        Object.defineProperty(this, \"logprobs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"safetyModel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inferenceAPIUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"https://api.together.xyz/inference\"\n        });\n        const apiKey = inputs.apiKey ?? getEnvironmentVariable(\"TOGETHER_AI_API_KEY\");\n        if (!apiKey) {\n            throw new Error(\"TOGETHER_AI_API_KEY not found.\");\n        }\n        if (!inputs.model && !inputs.modelName) {\n            throw new Error(\"Model name is required for TogetherAI.\");\n        }\n        this.apiKey = apiKey;\n        this.temperature = inputs?.temperature ?? this.temperature;\n        this.topK = inputs?.topK ?? this.topK;\n        this.topP = inputs?.topP ?? this.topP;\n        this.modelName = inputs.model ?? inputs.modelName ?? \"\";\n        this.model = this.modelName;\n        this.streaming = inputs.streaming ?? this.streaming;\n        this.repetitionPenalty = inputs.repetitionPenalty ?? this.repetitionPenalty;\n        this.logprobs = inputs.logprobs;\n        this.safetyModel = inputs.safetyModel;\n        this.maxTokens = inputs.maxTokens;\n        this.stop = inputs.stop;\n    }\n    _llmType() {\n        return \"together_ai\";\n    }\n    constructHeaders() {\n        return {\n            accept: \"application/json\",\n            \"content-type\": \"application/json\",\n            Authorization: `Bearer ${this.apiKey}`,\n        };\n    }\n    constructBody(prompt, options) {\n        const body = {\n            model: options?.model ?? options?.modelName ?? this?.model,\n            prompt,\n            temperature: this?.temperature ?? options?.temperature,\n            top_k: this?.topK ?? options?.topK,\n            top_p: this?.topP ?? options?.topP,\n            repetition_penalty: this?.repetitionPenalty ?? options?.repetitionPenalty,\n            logprobs: this?.logprobs ?? options?.logprobs,\n            stream_tokens: this?.streaming,\n            safety_model: this?.safetyModel ?? options?.safetyModel,\n            max_tokens: this?.maxTokens ?? options?.maxTokens,\n            stop: this?.stop ?? options?.stop,\n        };\n        return body;\n    }\n    async completionWithRetry(prompt, options) {\n        return this.caller.call(async () => {\n            const fetchResponse = await fetch(this.inferenceAPIUrl, {\n                method: \"POST\",\n                headers: {\n                    ...this.constructHeaders(),\n                },\n                body: JSON.stringify(this.constructBody(prompt, options)),\n            });\n            if (fetchResponse.status === 200) {\n                return fetchResponse.json();\n            }\n            const errorResponse = await fetchResponse.json();\n            throw new Error(`Error getting prompt completion from Together AI. ${JSON.stringify(errorResponse, null, 2)}`);\n        });\n    }\n    /** @ignore */\n    async _call(prompt, options) {\n        const response = await this.completionWithRetry(prompt, options);\n        if (response.output) {\n            return response.output.choices[0]?.text ?? \"\";\n        }\n        else {\n            return response.choices?.[0]?.text ?? \"\";\n        }\n    }\n    async *_streamResponseChunks(prompt, options, runManager) {\n        const fetchResponse = await fetch(this.inferenceAPIUrl, {\n            method: \"POST\",\n            headers: {\n                ...this.constructHeaders(),\n            },\n            body: JSON.stringify(this.constructBody(prompt, options)),\n        });\n        if (fetchResponse.status !== 200 ?? !fetchResponse.body) {\n            const errorResponse = await fetchResponse.json();\n            throw new Error(`Error getting prompt completion from Together AI. ${JSON.stringify(errorResponse, null, 2)}`);\n        }\n        const stream = convertEventStreamToIterableReadableDataStream(fetchResponse.body);\n        for await (const chunk of stream) {\n            if (chunk !== \"[DONE]\") {\n                const parsedChunk = JSON.parse(chunk);\n                const generationChunk = new GenerationChunk({\n                    text: parsedChunk.choices[0].text ?? \"\",\n                });\n                yield generationChunk;\n                // eslint-disable-next-line no-void\n                void runManager?.handleLLMNewToken(generationChunk.text ?? \"\");\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
